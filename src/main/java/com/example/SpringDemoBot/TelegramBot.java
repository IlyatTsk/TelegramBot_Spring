package com.example.SpringDemoBot;


import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.telegram.telegrambots.bots.TelegramLongPollingBot;
import org.telegram.telegrambots.meta.api.methods.commands.SetMyCommands;
import org.telegram.telegrambots.meta.api.methods.send.SendMessage;
import org.telegram.telegrambots.meta.api.objects.Update;
import org.telegram.telegrambots.meta.api.objects.commands.BotCommand;
import org.telegram.telegrambots.meta.api.objects.commands.scope.BotCommandScopeDefault;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.ReplyKeyboardMarkup;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.KeyboardRow;
import org.telegram.telegrambots.meta.exceptions.TelegramApiException;

import java.util.ArrayList;
import java.util.List;

@Slf4j
@Component
public class TelegramBot extends TelegramLongPollingBot {

    final BotConfig config;

    public TelegramBot(BotConfig config) {
        this.config = config;
        List<BotCommand> listofCommands = new ArrayList<>();
        listofCommands.add(new BotCommand("/start", "Давай начнём!"));
        try {
            this.execute(new SetMyCommands(listofCommands, new BotCommandScopeDefault(), null));
        } catch (TelegramApiException e) {
            e.printStackTrace();
        }
    }

    @Override
    public String getBotUsername() {
        return config.getBotName();
    }

    @Override
    public String getBotToken() {
        return config.getToken();
    }

    @Override
    public void onUpdateReceived(Update update) {

        if (update.hasMessage() && update.getMessage().hasText()) {
            String messageText = update.getMessage().getText();
            long chatId = update.getMessage().getChatId();

            switch (messageText) {
                case "/start":
                    startCommandReceived(chatId, update.getMessage().getChat().getFirstName());
                    break;

                case "Вернуться в главное меню":
                    sendMainMenu(chatId);
                    break;

                case "Жизненный цикл ПО":
                    sendSoftwareLifecycleMenu(chatId);
                    break;

                case "Жизненный цикл разработки":
                    showLifeCycle(chatId);
                    break;

                case "Модели разработки ПО":
                    sendModelsDev(chatId);
                    break;

                case "Водопадная модель":
                    showWaterfallModel(chatId);
                    break;

                case "V-Образная модель":
                    showVModel(chatId);
                    break;

                case "Итерационная инкрементальная модель":
                    showIterativeModel(chatId);
                    break;

                case "Спиральная модель":
                    showSpiralModel(chatId);
                    break;

                case "Методолгия Agile":
                    showAgileMethodology(chatId);
                    break;

                case "Основы тестирования":
                    sendBaseTesting(chatId);
                    break;

                case "Определение и цели тестирования":
                    showDefinitionOfTesting(chatId);
                    break;

                case "Принципы тестирования":
                    showPrincipesTesting(chatId);
                    break;

                case "Кто такой тестировщик":
                    showWhoIsTester(chatId);
                    break;

                case "Баг":
                    showDefinitionOfBug(chatId);
                    break;

                case "Виды тестирования":
                    showTypesTesting(chatId);
                    break;

                case "Тестовая документация":
                    sendTestDocumentation(chatId);
                    break;

                case "Тест-план":
                    showTestPlan(chatId);
                    break;

                case "Тестовая стратегия":
                    showTestStrategy(chatId);
                    break;

                case "Чек-лист":
                    showCheckList(chatId);
                    break;

                case "Тест-кейс":
                    showTestCase(chatId);
                    break;

                case "Баг-репорт":
                    showBugReport(chatId);
                    break;

                case "Отчет о тестировании":
                    showTestReport(chatId);
                    break;

                case "Техники тест-дизайна":
                    showTestDesign(chatId);
                    break;

                case "Основы баз данных":
                    showDataBase(chatId);
                    break;


                default:
                    sendMessage(chatId, "Извини, пока такой команды не существует");
            }
        }
    }


    private void startCommandReceived(long chatId, String name) {
        String answer = "Привет, " + name + ", этот бот поможет тебе быстро найти краткую информацию по тестированию";
        sendMessage(chatId, answer);
    }

    private void sendMessage(long chatId, String textToSend) {
        SendMessage message = new SendMessage();
        message.setChatId(String.valueOf(chatId));
        message.setText(textToSend);

        ReplyKeyboardMarkup keyboardMarkup = new ReplyKeyboardMarkup();

        List<KeyboardRow> keyboardRows = new ArrayList<>();

        KeyboardRow row = new KeyboardRow();

        row.add("Жизненный цикл ПО");
        row.add("Модели разработки ПО");
        keyboardRows.add(row);

        row = new KeyboardRow();

        row.add("Основы тестирования");
        row.add("Виды тестирования");
        keyboardRows.add(row);

        row = new KeyboardRow();

        row.add("Тестовая документация");
        row.add("Техники тест-дизайна");
        keyboardRows.add(row);

        row = new KeyboardRow();

        row.add("Основы баз данных");
        row.add("API");
        keyboardRows.add(row);

        row = new KeyboardRow();

        row.add("HTML, CSS для тестировщика");
        //row.add("Словарик тестировщика");
        keyboardRows.add(row);

        keyboardMarkup.setKeyboard(keyboardRows);

        message.setReplyMarkup(keyboardMarkup);

        try {
            execute(message);
        } catch (TelegramApiException e) {
            e.printStackTrace();
        }
    }

    private void sendSoftwareLifecycleMenu(long chatId) {
        SendMessage message = new SendMessage();
        message.setChatId(String.valueOf(chatId));
        message.setText("Выбери, что конкретно тебя интересует");

        ReplyKeyboardMarkup keyboardMarkup = new ReplyKeyboardMarkup();

        List<KeyboardRow> keyboardRows = new ArrayList<>();
        KeyboardRow row = new KeyboardRow();

        row.add("Жизненный цикл разработки");
        keyboardRows.add(row);

        row = new KeyboardRow();
        row.add("Назад");
        keyboardRows.add(row);

        keyboardMarkup.setKeyboard(keyboardRows);
        message.setReplyMarkup(keyboardMarkup);

        try {
            execute(message);
        } catch (TelegramApiException e) {
            e.printStackTrace();
        }
    }

    private void sendMainMenu(long chatId) {
        SendMessage message = new SendMessage();
        message.setChatId(String.valueOf(chatId));
        message.setText("Главное меню:");
        ReplyKeyboardMarkup keyboardMarkup = new ReplyKeyboardMarkup();

        List<KeyboardRow> keyboardRows = new ArrayList<>();

        KeyboardRow row = new KeyboardRow();

        row.add("Жизненный цикл ПО");
        row.add("Модели разработки ПО");
        keyboardRows.add(row);

        row = new KeyboardRow();

        row.add("Основы тестирования");
        row.add("Виды тестирования");
        keyboardRows.add(row);

        row = new KeyboardRow();

        row.add("Тестовая документация");
        row.add("Техники тест-дизайна");
        keyboardRows.add(row);

        row = new KeyboardRow();

        row.add("Основы баз данных.SQL запросы");
        row.add("API");
        keyboardRows.add(row);

        row = new KeyboardRow();

        row.add("HTML, CSS для тестировщика");
        row.add("Словарик тестировщика");
        keyboardRows.add(row);

        keyboardMarkup.setKeyboard(keyboardRows);

        message.setReplyMarkup(keyboardMarkup);

        try {
            execute(message);
        } catch (TelegramApiException e) {
            e.printStackTrace();
        }
    }

    private void sendModelsDev(long chatId) {
        SendMessage message = new SendMessage();
        message.setChatId(String.valueOf(chatId));
        message.setText("Выбери, что конкретно тебя интересует");

        ReplyKeyboardMarkup keyboardMarkup = new ReplyKeyboardMarkup();

        List<KeyboardRow> keyboardRows = new ArrayList<>();
        KeyboardRow row = new KeyboardRow();

        row.add("Водопадная модель");
        row.add("V-Образная модель");
        keyboardRows.add(row);

        row = new KeyboardRow();
        row.add("Итерационная инкрементальная модель");
        row.add("Спиральная модель");
        keyboardRows.add(row);

        row = new KeyboardRow();
        row.add("Методолгия Agile");
        keyboardRows.add(row);

        row = new KeyboardRow();
        row.add("Назад");
        keyboardRows.add(row);

        keyboardMarkup.setKeyboard(keyboardRows);
        message.setReplyMarkup(keyboardMarkup);

        try {
            execute(message);
        } catch (TelegramApiException e) {
            e.printStackTrace();
        }
    }

    private void showLifeCycle(long chatId) {
        String info = "• Анализ требований: отвечает на вопрос «Какие проблемы требуют решений?».\n" +
                "• Планирование: отвечает на вопрос «Что мы хотим сделать?».\n" +
                "• Проектирование и дизайн: отвечает на вопрос «Как мы добьемся наших целей?».\n" +
                "• Разработка ПО: регулирует процесс создания продукта.\n" +
                "• Тестирование: регулирует обеспечение качественной работы продукта.\n" +
                "• Внедрение и поддержка: регулирует использование финального продукта.\n";

        sendMessage(chatId, info);
    }

    private void showWaterfallModel(long chatId) {
        String info = "Waterfall Model – подразумевает последовательное прохождение стадий, каждая из которых должна завершиться полно\u0002стью до начала следующей.\n" +
                "Особенности:\n" +
                "• Разработка проходит быстро.\n" +
                "• Стоимость и сроки заранее определены.\n" +
                "• Хороший результат только в проектах с четко и заранее определенными требованиями.\n" +
                "• Нет возможности сделать шаг назад.";
        sendMessage(chatId, info);
    }

    private void showVModel(long chatId) {
        String info = "V-Model – Унаследовала структуру «шаг за шагом» от водопадной модели. Применима к системам, которым особенно \n" +
                "важно бесперебойное функционирование. Например, прикладные программы в клиниках для наблюдения за пациентами, интегрированное ПО для механизмов управления аварийными подушками безопасности в транспортных средствах и т.д.\n" +
                "V-образную модель ещё называют разработкой через тестирование.\n" +
                "Особенности:\n" +
                "• Направлена на тщательную проверку и тестирование продукта с ранних стадий проектирования.\n" +
                "• Стадия тестирования проводится одновременно с соответствующей стадией разработки.\n" +
                "• Количество ошибок в архитектуре ПО сводится к минимуму.\n" +
                "• Если при разработке архитектуры была допущена ошибка, то вернуться и исправить её будет стоить дорого, как и в «водопаде».";
        sendMessage(chatId, info);
    }

    private void showIterativeModel(long chatId) {
        String info = "ИТЕРАТИВНОСТЬ – повторение операций в целях переработки результатов предыдущего этапа. \n " +
                "ИНКРЕМЕНТИРОВАНИЕ – приращение результатов предыдущего этапа.\n" +
                "Проект при этом подходе в каждой фазе развития проходит повторяющийся цикл (итерация): \n" +
                "Планирование – Реализация – Проверка – Корректировка.\n" +
                "Преимущества:\n" +
                "• Гибкость в принятии новых требований или изменений .\n" +
                "• Возможность адаптации процесса на основе уроков, извлеченных из предыдущих итераций.\n" +
                "• Более короткие сроки вывода продукта на рынок.\n" +
                "Недостатки:\n" +
                "• Стоимость продукта неизвестна \n" +
                "• Могут возникнуть проблемы с архитектурой системы, поскольку требования для всего жизненного цикла программы не собираются.";
        sendMessage(chatId, info);
    }

    private void showSpiralModel(long chatId) {
        String info = "Spiral Model – это модель процесса разработки ПО с учетом рисков. Это комбинация модели водопада и итеративной модели. Spiral Model помогает внедрить элементы разработки программного обеспечения из нескольких моделей процессов для программного проекта на основе уникальных шаблонов рисков, обеспечивая эффективный процесс разработки.\n" +
                "Каждая фаза (итерация) спиральной модели в разработке программного обеспечения начинается с определения цели проектирования и заканчивается тем, что клиент просматривает прогресс.\n" +
                "Преимущества:\n" +
                "• Анализ рисков и управление рисками на каждом этапе.\n" +
                "• Подходит для больших проектов.\n" +
                "• Возможность изменения в требованиях на поздних этапах.\n" +
                "• Заказчик может наблюдать за развитием продукта на ранней стадии разработки.\n" +
                "Недостатки:\n" +
                "• Спиральная модель намного сложнее других моделей SDLC.\n" +
                "• Не подходит для небольших проектов, так как она дорогая.\n" +
                "• Успешное завершение проекта зависит от анализа рисков. \n" +
                "• Количество этапов неизвестно в начале проекта";
        sendMessage(chatId, info);
    }

    private void showAgileMethodology(long chatId) {
        String info = "Методология Agile – это набор практик, целью которых является оперативная реакция на изменения в ходе рабочего процесса. Такие подходы помогают командам быстро реагировать на обратную связь от клиентов и заказчиков, тем самым постоянно улучшая производимый продукт. \n\n" +
                "Ценности Agile\n" +
                "• Люди важнее процессов и стандартных инструментов;\n" +
                "• Создание продукта важнее, чем подбор и согласование документации;\n" +
                "• Услышать позицию клиента и сотрудничать с ним превыше контракта;\n" +
                "• Вносить коррективы важнее, чем изначально разработанная стратегия.\n\n" +
                "Суть AGILE МАНИФЕСТА:\n" +
                "• Вся работа над проектом разделяется на короткие циклы (итерации) и ведется поэтапно;\n" +
                "• В конце каждой итерации заказчик получает готовый минимально работающий продукт или его часть, которую уже можно использовать;\n" +
                "• В течение всего рабочего процесса команда сотрудничает с заказчиком;\n" +
                "• Любые изменения в проекте приветствуются и быстро интегрируются в работу.\n\n" +
                "Проще говоря, Agile — это своеобразная философия, но как ее придерживаться, зависит от конкретного случая. \n" +
                "Есть 2 основных фреймворка, которые основываются на базовых принципах Agile: Scrum и Kanban.\n\n" +
                "SCRUM\n" +
                "Подход предполагает взаимодействие на каждом этапе разработки ПО, не только команды разработчиков (Delivery Team), но и самого заказчика (Product owner), а также Scrum-мастера. \n" +
                "Суть данного фреймворка:\n" +
                "• Работа делится на спринты длительностью 1-3 недели.\n" +
                "• Перед началом спринта команда сама формирует список задач на итерацию.\n" +
                "• Во время каждого спринта создается продукт или услуга, которые можно продемонстрировать клиенту.\n" +
                "• После выполнения спринта проводится ретроспектива. Это - митинг, цель которого получить фидбэк от каждого участника команды, выявить текущие успехи и проблемы, то есть оценка и анализ проделанной работы.\n" +
                "• Каждый последующий этап будет наращивать функционал проекта, пока все функции не будут реализованы.\n" +
                "Scrum подходит для объемных проектов.\n\n" +
                "KANBAN\n" +
                "Канбан – это способ правильного выстраивания процесса с целью максимально эффективного использования возможности каждого сотрудника. Подход позволяет оптимизировать работу команды через разделение объемных этапов на отдельные операции. \n" +
                "Система Канбан основана на принципах\n" +
                "• Визуализация. Основа Канбан – визуальная доска, на которой представлены этапы выполнения текущей задачи: «запланировано» / «выполняется» / «сделано».\n" +
                "• Разделение задач. Четкое понимание целей упрощает процесс.\n" +
                "• Фокусировка на работе. Невыполненные задачи требуют особого внимания. Если процесс затягивается, нужно подключать до\u0002полнительных сотрудников и перераспределять ресурсы.";
        sendMessage(chatId, info);
    }

    private void sendBaseTesting(long chatId) {
        SendMessage message = new SendMessage();
        message.setChatId(String.valueOf(chatId));
        message.setText("Выбери, что конкретно тебя интересует");

        ReplyKeyboardMarkup keyboardMarkup = new ReplyKeyboardMarkup();

        List<KeyboardRow> keyboardRows = new ArrayList<>();
        KeyboardRow row = new KeyboardRow();

        row = new KeyboardRow();
        row.add("Определение и цели тестирования");
        row.add("Принципы тестирования");
        keyboardRows.add(row);

        row = new KeyboardRow();
        row.add("Кто такой тестировщик");
        row.add("Баг");
        keyboardRows.add(row);

        row = new KeyboardRow();
        row.add("Назад");
        keyboardRows.add(row);

        keyboardMarkup.setKeyboard(keyboardRows);
        message.setReplyMarkup(keyboardMarkup);

        try {
            execute(message);
        } catch (TelegramApiException e) {
            e.printStackTrace();
        }
    }

    private void showDefinitionOfTesting(long chatId) {
        String info = "Тестирование (Software Testing) – проверка соответствия реальных и ожидаемых результатов поведения программы, проводимая на конечном наборе тестов, выбранном определённым образом.\n\n" +
                "Цели тестирования:\n" +
                "• Выявление дефектов до того, как их обнаружат пользователи.\n" +
                "• Предоставление актуальной информации о состоянии продукта на данный момент.\n" +
                "• Проверка на соответствие ПО всем заявленным требованиям.";
        sendMessage(chatId, info);
    }

    private void showPrincipesTesting(long chatId) {
        String info = "Принципы тестирования:\n" +
                "• Тестирование демонстрирует наличие дефектов. Тестирование только снижает вероятность наличия дефектов, которые находятся в ПО, но не гарантирует их отсутствия.\n\n" +
                "• Исчерпывающее тестирование невозможно. Полное тестирование с использованием всех входных комбинаций данных, результатов и предусловий физически невыполнимо.\n\n" +
                "• Раннее тестирование. Следует начинать тестирование на ранних стадиях жизненного цикла разработки ПО, чтобы найти дефекты как можно раньше.\n\n" +
                "• Скопление дефектов. Большая часть дефектов находится в ограниченном количестве модулей.\n\n" +
                "• Эффект (парадокс) пестицида. Если повторять те же тестовые сценарии снова и снова, в какой-то момент этот набор тестов перестанет выявлять новые дефекты. \n\n" +
                "Суть его в том, что если вы долго проводите одни и те же проверки, скорее всего новых багов вы не найдете. Именно поэтому периодически нужно «встряхивать» тестовую базу, ревьюить её новыми сотрудниками, проводить исследовательское тестирование.\n\n" +
                "• Тестирование зависит от контекста. Например, программное обеспечение, в котором критически важна безопасность, тестируется иначе, чем новостной портал.\n\n" +
                "• Заблуждение об отсутствии ошибок. Отсутствие найденных дефектов при тестировании не всегда означает готовность продукта к релизу. Система должна быть удобна пользователю в использовании и удовлетворять его ожиданиям и потребностям.";
        sendMessage(chatId, info);
    }

    private void showWhoIsTester(long chatId) {
        String info = "Tестировщик – это специалист, который проверяет качество программного обеспечения и уровень его соответствия заранее определённым требованиям. \n\n" +
                "QA И ТЕСТИРОВАНИЕ\n" +
                "Quality Assurance (QA) – QA обеспечивает правильность процесса тестирования, подходит к контролю качества глобально, следит за нормализацией процессов.\n" +
                "Quality Control (QC) – QC предполагает контроль соблюдения требований.\n" +
                "Testing – Тестировщик обеспечивает сбор данных, которые вносятся в документы, созданные в ходе работы QC.\n\n" +
                "В реальной жизни IT-индустрии встречаются только два названия профессии QA-инженер и Тестировщик ПО.\n" +
                "Причём очень часто эти понятия взаимозаменяются и путаются. Пример: «Ищу Тестировщика ПО (QA-инженера)». По факту многие работодатели ищут тестировщика ПО (если ориентироваться по описанию обязанностей), но в названии вакансии может быть QA-инженер. \n\n" +
                "Тестировщик ищет баги и сообщает о них. Но главная задача тестировщика – предоставить информацию о том, как работает приложение.";
        sendMessage(chatId, info);
    }

    private void showDefinitionOfBug(long chatId) {
        String info = "БАГ (bug, дефект) – отклонение фактического результата от ожидаемого. Найденные баги оформляются в баг-репорты\n\n" +
                "Ожидаемый результат (Expected result) – описание того, как именно должна работать система в соответствии с документацией.\n\n" +
                "Фактический результат (Actual result) – это тот результат, который получает тестировщик во время тестирования. То есть то, как система работает на самом деле. \n\n" +
                "ЖИЗНЕННЫЙ ЦИКЛ БАГА\n" +
                "• Новый (New) – Впервые найденный баг, занесённый в систему. \n" +
                "• Отказ (Rejected) – Баг отклонён. Причины: некачественное описание или такой дефект уже существует, невозможность воспроизвести баг. \n" +
                "• Закрыт (Closed). – Баг перестал быть актуальным.\n" +
                "• Назначен (Assigned) – Дефект просмотрен и открыт, то есть признан для исправления.\n" +
                "• Решен (Fixed) – Дефект исправили, и он в этом состоянии требует перепроверки тестировщиком.\n" +
                "• Переоткрыт (Re-opened) – Если дефект не исправлен или исправлен не полностью.\n\n" +
                "ОШИБКА – действие, приводящее к некорректным результатам – ошибки в коде при разработке.\n\n" +
                "ДЕФЕКТ (баг) – скрытый недостаток в ПО, возникший из-за ошибки в написании кода. Дефект, обнаруженный тестировщиком называется багом.\n\n" +
                "СБОЙ (отказ) – упущенный при тестировании деффект, который обнаружил пользователь";
        sendMessage(chatId, info);
    }

    private void showTypesTesting(long chatId) {
        String info = "ВИДЫ ТЕСТИРОВАНИЯ (упрощенная классификация)\n\n" +
                "ПО ЗАПУСКУ КОДА НА ИСПОЛНЕНИЕ:\n" +
                "• Статическое тестирование – без запуска.\n" +
                "• Динамическое тестирование – с запуском.\n\n" +
                "ПО ДОСТУПУ К КОДУ И АРХИТЕКТУРЕ ПРИЛОЖЕНИЯ:\n" +
                "• Метод белого ящика – доступ к коду есть.\n" +
                "• Метод чёрного ящика – доступа к коду нет.\n" +
                "• Метод серого ящика – к части кода доступ есть, к части – нет.\n\n" +
                "ПО СТЕПЕНИ АВТОМАТИЗАЦИИ:\n" +
                "• Ручное тестирование.\n" +
                "• Автоматизированное тестирование.\n\n" +
                "ПО УРОВНЮ ДЕТАЛИЗАЦИИ ПРИЛОЖЕНИЯ:\n" +
                "• Модульное тестирование.\n" +
                "• Интеграционное тестирование – проверка взаимодействия \n" +
                "между модулями.\n" +
                "• Системное тестирование – приложение проверяется как единое целое.\n\n" +
                "ПО СТЕПЕНИ ВАЖНОСТИ ТЕСТИРУЕМЫХ ФУНКЦИЙ:\n" +
                "• Дымовое тестирование – проверка самой важной, самой \n" +
                "ключевой функциональности приложения.\n" +
                "• Тестирование критического пути – проверка функциональности, используемой типичными пользователями в типичной повседневной деятельности.\n" +
                "• Расширенное тестирование – проверка всей (остальной) функциональности, заявленной в требованиях.\n\n" +
                "ПО ПРИНЦИПАМ РАБОТЫ С ПРИЛОЖЕНИЕМ:\n" +
                "• Позитивное тестирование – это тестирование с применением сценариев, которые соответствуют нормальному (штатному, ожидаемому) поведению системы. С его помощью мы \n" +
                "можем определить, что система делает то, для чего и была создана.\n" +
                "• Негативное тестирование – тестирование направлено на проверку устойчивости системы к различным воздействиям, валидации неверных данных, обработку исключительных ситуаций.\n";
        sendMessage(chatId, info);
    }

    private void sendTestDocumentation(long chatId) {
        SendMessage message = new SendMessage();
        message.setChatId(String.valueOf(chatId));
        message.setText("Выбери, что конкретно тебя интересует");

        ReplyKeyboardMarkup keyboardMarkup = new ReplyKeyboardMarkup();

        List<KeyboardRow> keyboardRows = new ArrayList<>();

        KeyboardRow row = new KeyboardRow();
        row.add("Тест-план");
        row.add("Тестовая стратегия");
        keyboardRows.add(row);

        row = new KeyboardRow();
        row.add("Чек-лист");
        row.add("Тест-кейс");
        keyboardRows.add(row);

        row = new KeyboardRow();
        row.add("Баг-репорт");
        row.add("Отчет о тестировании");
        keyboardRows.add(row);

        row = new KeyboardRow();
        row.add("Назад");
        keyboardRows.add(row);

        keyboardMarkup.setKeyboard(keyboardRows);
        message.setReplyMarkup(keyboardMarkup);

        try {
            execute(message);
        } catch (TelegramApiException e) {
            e.printStackTrace();
        }
    }

    private void showTestPlan(long chatId) {
        String info = "ТЕСТ-ПЛАН\n\n" +
                "Тест-план (Test Plan) – документ, описывающий весь объём работ по тестированию: описания объекта тестирования, стратегии, критериев начала и окончания тестирования, необходимое оборудование и знания, оценки рисков с вариантами их разрешения.\n\n" +
                "Тест-план призван ответить на следующие вопросы:\n" +
                "• Что НАДО тестировать?\n" +
                "• Что БУДЕМ тестировать? (Тест-Аналитик).\n" +
                "• КАК будем тестировать? (Тест-Дизайнер).\n" +
                "• На каких уровнях будем проводить тестирование?\n" +
                "• Какие виды тестирования применим?\n" +
                "• Каким образом будем тестировать – руками или автотестами?\n" +
                "• КОГДА будем тестировать? Оценка трудозатрат и сроков.\n" +
                "• Какие РИСКИ возможны? Какие затраты времени, средств и труда они могут повлечь. Степень их влияния на исход проекта, прописать мероприятия по нейтрализации последствий срабатывания рисков.";
        sendMessage(chatId, info);
    }

    private void showTestStrategy(long chatId) {
        String info = "Тестовая стратегия. Определяет то, как тестируем ПО. \n" +
                "Это набор идей, которые направляют процесс тестирования.";
        sendMessage(chatId, info);
    }

    private void showCheckList(long chatId) {
        String info = "ЧЕК-ЛИСТ\n\n" +
                "Чек-лист – это список, содержащий ряд необходимых проверок во время тестирования программного продукта\n" +
                "ЗАДАЧИ, КОТОРЫЕ РЕШАЕТ ЧЕК-ЛИСТ:\n" +
                "• Систематизирует процесс. Чек-лист разбивает сложную работу на части и помогает не упустить из внимания важные детали\n" +
                "• Облегчают делегирование. С инструкцией сотрудникам проще разобраться в новой задаче без потери качества\n" +
                "• Снижают необходимость в контроле. Руководитель может отследить ход работ и корректировать процесс на любом этапе. \n" +
                "Четкий алгоритм облегчает проверку задач.";
        sendMessage(chatId, info);
    }

    private void showTestCase(long chatId) {
        String info = "ТЕСТ-КЕЙС\n\n" +
                "Тест-кейс – это документ, который описывает наши тесты. Говорит, как их выполнить, при каких условиях и что должно получиться после выполнения тех шагов, которые заложены в тест-кейсе, то есть каков ожидаемый результат.\n\n" +
                "Атрибуты тест-кейса\n\n" +
                "• ID – уникальный номер. Обычно проставляется автоматически в системах хранения тест-кейсов.\n" +
                "• Краткое описание тест-кейса (Name). Название тест-кейса должно быть коротким и понятным. Оба эти слова важны. \n" +
                "• Ссылка на требования. Ссылка на требование или ТЗ, на основе которого был составлен тест-кейс.\n" +
                "• Автор (Author). Тестировщик, написавший тест-кейс.\n" +
                "• Приоритет (Priority) – насколько важен этот тест-кейс, в какую очередь его стоит выполнять.\n" +
                "• Название/модуль/версия продукта (Component/Version) – описание ПО, на котором можно выполнить тест-кейс.\n" +
                "• Предварительные условия (Precondition) – шаги, которые необходимо выполнить перед началом тестирования.\n" +
                "• Шаги (Steps) – точная последовательность действий для выполнения проверки. Шаги должны быть четкими и понятными. \n" +
                "• Ожидаемый результат (Expected result) – что мы получаем после выполнения шагов.\n" +
                "• Приложения (Attachments) – дополнительная информация, которая поможет выполнить тест-кейс, например, скриншоты, текстовые файлы и прочие файлы.";
        sendMessage(chatId, info);
    }

    private void showBugReport(long chatId) {
        String info = "БАГ РЕПОРТ (Bug Report – «отчёт об ошибке») – это технический документ, поэтому он создается по определенным правилам. Формат баг-репорта меняется в зависимости от компании, но костяк и суть всегда сохраняются.\n\n" +
                "Атрибуты баг-репорта:\n" +
                "1. Заголовок ошибки отвечает на три вопроса:\n" +
                "• Что произошло?\n" +
                "• Где появилась ошибка?\n" +
                "• Когда или при каких условиях найден дефект?\n" +
                "2. Описание ошибки\n" +
                "3. Номер версии (Version)\n" +
                "4. Автор баг репорта (обычно это Тестировщик)\n" +
                "5. Серьёзность (Severity)\n" +
                "6. Приоритет (Priority)\n" +
                "7. Начальные условия. В случае, если есть специфичные действия или шаги воспроизведения достаточно объёмные, то указываются начальные условия.\n" +
                "8. Шаги воспроизведения. Шаги, при которых повторяется найденная ошибка\n" +
                "9. Ожидаемый результат\n" +
                "10. Фактический результат\n" +
                "11. Вложения";
        sendMessage(chatId, info);
    }

    private void showTestReport(long chatId) {
        String info = "Тест-репорт (Test report) – отчет о выполнении тест-кейсов, в нём обычно отмечается общая статистика, количество выполненных тест-кейсов и количество найденных ошибок.\n\n" +
        "Список данных, которые стоит указывать в отчете\n" +
                "• Состав команды\n" +
                "• Сроки выполнения, за которые составляется отчёт\n" +
                "• Описание процессов тестирования\n" +
                "• Изменения тестовой модели, дополнение ТК\n" +
                "• Процент пройденных ТК\n" +
                "• Критичные и блокирующие проблемы и принятые меры по их устранению\n" +
                "• Результаты регресса\n" +
                "• План на следующую итерацию/неделю/месяц \n\n" +
                "Метрика тестирования ПО определяется как количественная мера, которая помогает оценить прогресс, качество и работоспособность процесса тестирования программного обеспечения. \n" +
                "Метрика определяет в количественном выражении степени, в которой система, системный компонент или процесс обладает заданным атрибутом.\n\n" +
                "Программа и методика испытаний (ПМИ) – это технический документ, который формализует этап тестирования продукции и составляется на автоматизированную программу (АСУ) или систему. Документ предназначается для выявления параметров, которые обеспечивают определение причин сбоя, показателей качества системы, ее соответствие различным требованиям, проверку и получение проектных решений, а также характеризуют продолжительность и период испытаний.";
        sendMessage(chatId, info);
    }

    private void showTestDesign(long chatId) {
        String info = "ТЕСТ-ДИЗАЙН\n\n" +
                "Тест-дизайн – это этап процесса тестирования ПО, на котором проектируются и создаются тестовые случаи (тест-кейсы) в соответствии с определёнными ранее критериями качества и целями тестирования.\n\n" +
                "КЛАССЫ ЭКВИВАЛЕНТНОСТИ \n\n" +
                "КЛАССЫ ЭКВИВАЛЕНТНОСТИ – это техника, при которой мы разделяем функционал (часто диапазон возможных вводимых значений) на группы эквивалентных по своему влиянию на систему значений.\n" +
                "Любой тест, выполненный из одного и того же класса эквивалентности, приведет к точно такому же результату, как и выполнение всех остальных тестов из этого же класса\n\n" +
                "ГРАНИЧНОЕ ЗНАЧЕНИЕ\n\n" +
                "ГРАНИЧНОЕ ЗНАЧЕНИЕ – это значение, которое находится на границе классов эквивалентности.\n" +
                "Техника анализа граничных значений – техника, проверяющая поведение системы либо отдельного модуля на граничных значениях входных данных.\n" +
                "Большинство ошибок возникает именно на границах между классами эквивалентности. Т.е. тестировщику, в первую очередь, важно проверить переходы на стыке границ каждого класса.\n\n" +
                "СОСТОЯНИЕ и ПЕРЕХОДЫ\n\n" +
                "Тестирование состояний и переходов применяется к объкту, который может менять свое состояние в зависимости от действий, которые с ним совершают.\n" +
                "Тестирование перехода между состояниями помогает анализировать поведение приложения для различных входных условий. \n" +
                "Тестеры могут предоставлять положительные и отрицательные входные тестовые значения и записывать поведение системы.\n\n" +
                "ТАБЛИЦА ПРИНЯТИЯ РЕШЕНИЙ\n\n" +
                "ТАБЛИЦА РЕШЕНИЙ (Decision Table) – техника, помогающая наглядно изобразить комбинаторику условий из ТЗ.\n" +
                "По горизонтали. УСЛОВИЯ, которые влияют на результат. Обязательно в виде вопроса. ДЕЙСТВИЕ или следствия (описание ожидаемого результата). Обязательно утверждение и только одно.\n" +
                "По вертикали. ПРАВИЛА – комбинация входных условий, или проще тесты.\n\n" +
                "ПОПАРНОЕ ТЕСТИРОВАНИЕ\\n\n" +
                "Метод попарного тестирования (Pairwise testing) основан на идее: подавляющее большинство багов выявляется тестом, проверяющим либо один параметр, либо сочетание двух.\n" +
                "Ошибки, причиной которых явились комбинации трех и более параметров, как правило, значительно менее критичны.\n" +
                "ПРИМЕР. Имеем систему, которая зависит от нескольких входных параметров (10 параметров по два значения Вкл/Выкл). Все возможные варианты сочетания этих параметров – 1024 комбинации. Используя метод попарного тестирования – мы не тестируем все возможные сочетания, а составляем тесты так, чтобы" +
                "каждое значение параметра хотя бы один раз сочеталось с каждым значением остальных тестируемых параметров. " +
                "Таким образом, метод существенно сокращает количество тестов, а значит, и время тестирования\n\n" +
                "ИССЛЕДОВАТЕЛЬСКОЕ ТЕСТИРОВАНИЕ\n\n" +
                "Исследовательское тестирование (Exploratory Testing) – частично формализованный подход, в рамках которого тестировщик выполняет работу с продуктом по выбранному сценарию, который, в свою очередь, дорабатывается в процессе выполнения с целью более полного исследования приложения.\n\n" +
                "AD-HOC ТЕСТИРОВАНИЕ\n\n" +
                "Свободное (интуитивное) тестирование (Ad-hoc Testing) – полностью неформализованный подход, в котором не предполагается использования ни тест-кейсов, ни чек-листов, ни " +
                "сценариев. Тестировщик опирается на свою интуицию и опыт для спонтанного выполнения с продуктом действий, которые, " +
                "как он считает, могут обнаружить ошибку.\n\n" +
                "MONKEY ТЕСТИРОВАНИЕ\n\n" +
                "Monkey тестирование (Monkey Testing) – это метод тестирования ПО, при котором тестировщик вводит любые случайные входные данные без заранее определенных тестовых случаев и " +
                "проверяет поведение программного приложения, независимо от того, даёт ли оно сбой или нет. То есть тестируем без цели, " +
                "без плана. Просто тыкаемся везде с намерением что-то сломать. Как обезьянка.\n";
        sendMessage(chatId, info);
    }

    private void showDataBase(long chatId) {
        String info = "";
        sendMessage(chatId, info);
    }


}